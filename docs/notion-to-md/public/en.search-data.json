{"/docs/v4/concepts/media-handler/":{"data":{"best-practices#Best Practices":" Use unique filenames - Include the block ID in filenames to prevent collisions Implement proper error handling - Media downloads can fail for various reasons Set up cleanup processes - Prevent accumulating unused files over time Consider content updates - Your strategy should handle content that changes frequently ","media-handler-strategies#Media Handler Strategies":"notion-to-md v4 provides three strategies for handling media:\nDirect Strategy - Use Notion’s URLs directly (simplest but least reliable) Download Strategy - Download media files to your local filesystem Upload Strategy - Upload media files to an external service (S3, Cloudinary, etc.) When to Use Each Strategy Use Direct Strategy for temporary exports or testing Use Download Strategy for static sites, local applications, or when you need complete control Use Upload Strategy for production websites, CMS integration, or cloud-based workflows ","media-handling#Media Handling":"Media HandlingWhen converting Notion pages to Markdown, handling media files (images, videos, PDFs, etc.) is essential for a complete content migration. notion-to-md v4 provides powerful media handling capabilities that solve several key challenges.","media-manifest-management#Media Manifest Management":"notion-to-md v4 maintains a media manifest that tracks all processed media files. This enables:\nPerformance Optimization - Skip re-downloading unchanged files Intelligent Cleanup - Remove files no longer referenced in content Traceability - Track the relationship between Notion blocks and media files The manifest is stored by default in .notion-to-md/media/{page-id}_media.json and is managed automatically.","next-steps#Next Steps":"Now that you understand media handling, you might want to explore:\nPage References Guide - Handle links between pages Custom Renderers Guide - Create custom output formats Custom Exporters Guide - Control where content is saved ","preserving-external-urls#Preserving External URLs":"In some cases, you might want to download or upload media from Notion but leave external media URLs (like YouTube embeds or third-party images) unchanged. Use the preserveExternalUrls option:\n.downloadMediaTo({ outputDir: './public/images', transformPath: (localPath) =\u003e `/images/${path.basename(localPath)}`, preserveExternalUrls: true // Don't download external media }) ","troubleshooting#Troubleshooting":"Common Issues Missing media: Check if the media exists in the Notion page and is accessible Permission errors: Ensure your application has write access to the output directory API limits: Notion or your upload service might have rate limits Debugging If you encounter issues with media handling, you can:\nCheck the manifest file to see what media files have been processed Use the failForward option to continue processing despite errors Implement detailed logging in your upload/download handlers ","using-external-media-services#Using External Media Services":"You can integrate with popular media services for more advanced features:\nCloudinary Example import { NotionConverter } from 'notion-to-md'; import { v2 as cloudinary } from 'cloudinary'; import fetch from 'node-fetch'; // Configure Cloudinary cloudinary.config({ cloud_name: 'your-cloud-name', api_key: 'your-api-key', api_secret: 'your-api-secret' }); const n2m = new NotionConverter(notionClient) .uploadMediaUsing({ uploadHandler: async (url, blockId) =\u003e { // Upload directly from URL to Cloudinary const result = await cloudinary.uploader.upload(url, { folder: 'notion-content', public_id: blockId, overwrite: true }); // Return optimized URL return result.secure_url; }, cleanupHandler: async (entry) =\u003e { // Extract public_id from the URL const urlParts = entry.mediaInfo.uploadedUrl.split('/'); const publicId = urlParts[urlParts.length - 1].split('.')[0]; // Delete from Cloudinary await cloudinary.uploader.destroy(`notion-content/${publicId}`); } }); ","using-the-download-strategy#Using the Download Strategy":"The Download Strategy downloads media files from Notion and saves them to a local directory.\nBasic Configuration import { NotionConverter } from 'notion-to-md'; import * as path from 'path'; const n2m = new NotionConverter(notionClient) .downloadMediaTo({ outputDir: './public/images', transformPath: (localPath) =\u003e `/images/${path.basename(localPath)}` }); await n2m.convert('your-page-id'); Configuration Options The Download Strategy accepts these options:\noutputDir (required): Directory where media files will be saved transformPath: Function to convert local paths to URLs in the output preserveExternalUrls: Whether to keep external URLs unchanged (default: false) failForward: Continue processing even if media download fails (default: true) How It Works The media handler identifies all media blocks in the Notion content For each media block: The file is downloaded from Notion The content type is detected The file is saved to the specified directory The URL in the block is updated to reference the new location Path Transformation The transformPath function controls how local file paths are converted to URLs in your output. This is important for ensuring your content correctly references the media files.\n// Example: Convert local server path to a web URL .downloadMediaTo({ outputDir: './public/images', transformPath: (localPath) =\u003e { // Extract just the filename from the full path const filename = path.basename(localPath); // Return a web-accessible URL return `/images/${filename}`; } }) Without transformation, the paths in your content would point to server-side locations that aren’t accessible via a web browser.","using-the-upload-strategy#Using the Upload Strategy":"The Upload Strategy uploads media files to an external service like AWS S3, Cloudinary, or any custom storage system.\nBasic Configuration import { NotionConverter } from 'notion-to-md'; import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3'; import { getSignedUrl } from '@aws-sdk/s3-request-presigner'; import fetch from 'node-fetch'; // Initialize S3 client const s3Client = new S3Client({ region: 'us-east-1' }); const BUCKET_NAME = 'my-notion-media'; const n2m = new NotionConverter(notionClient) .uploadMediaUsing({ // Upload handler function uploadHandler: async (url, blockId) =\u003e { // Download the file from Notion const response = await fetch(url); const buffer = await response.arrayBuffer(); // Generate a filename based on the block ID const filename = `${blockId}.jpg`; const key = `notion-media/${filename}`; // Upload to S3 await s3Client.send(new PutObjectCommand({ Bucket: BUCKET_NAME, Key: key, Body: Buffer.from(buffer), ContentType: response.headers.get('content-type') })); // Return the new URL return `https://${BUCKET_NAME}.s3.amazonaws.com/${key}`; }, // Optional: cleanup handler to delete files when no longer needed cleanupHandler: async (entry) =\u003e { // Extract the key from the URL const url = new URL(entry.mediaInfo.uploadedUrl); const key = url.pathname.substring(1); // Remove leading slash // Delete from S3 await s3Client.send(new DeleteObjectCommand({ Bucket: BUCKET_NAME, Key: key })); } }); await n2m.convert('your-page-id'); Configuration Options The Upload Strategy accepts these options:\nuploadHandler (required): Function that uploads media and returns the new URL cleanupHandler: Function to cleanup media files when they’re no longer needed transformPath: Function to transform uploaded URLs preserveExternalUrls: Whether to keep external URLs unchanged (default: false) failForward: Continue processing even if media upload fails (default: true) How It Works The media handler identifies all media blocks in the Notion content For each media block: The uploadHandler is called with the original URL and block ID Your handler downloads and uploads the file to your preferred destination Your handler returns the new permanent URL The URL in the block is updated to reference the new location Cleanup Process The cleanup handler is an important feature that prevents accumulating unused media files. It’s called in these situations:\nWhen a block containing media is removed from the Notion page When a media file in a block is replaced with a different file When manually triggered during maintenance tasks This ensures your storage doesn’t accumulate orphaned media files over time.","why-media-handling-matters#Why Media Handling Matters":"Notion stores media files on temporary URLs that expire after a short period. When you convert Notion content to Markdown, you need a solution for these media references:\nPermanence - Notion’s media URLs expire, breaking references in your output content Ownership - You might want to host media files yourself rather than relying on Notion Optimization - You may need to process images (resize, compress, format conversion) Organization - Media files should be stored in a structured way that makes sense for your project Without proper media handling, your converted content would contain broken image links after a short time."},"title":"Media Handling"},"/docs/v4/getting-started/":{"data":{"":"This guide will help you quickly set up notion-to-md v4 and convert your first Notion page to Markdown.","basic-usage#Basic Usage":"Here’s a simple example demonstrating how to convert a Notion page to Markdown:\nimport { Client } from '@notionhq/client'; import { NotionConverter } from 'notion-to-md'; import * as fs from 'fs/promises'; // Initialize the Notion client with your integration token const notion = new Client({ auth: 'your-notion-integration-token', }); // Create a basic NotionConverter instance const n2m = new NotionConverter(notion); async function convertPage() { try { // Replace with your actual page ID const pageId = 'your-notion-page-id'; // Convert the page const result = await n2m.convert(pageId); // Save the markdown content to a file await fs.writeFile('output.md', result.content, 'utf-8'); console.log('✓ Successfully converted page to markdown!'); } catch (error) { console.error('Conversion failed:', error); } } convertPage(); ","installation#Installation":"First, install the package using npm or yarn:\nnpm install notion-to-md ","next-steps#Next Steps":"Once you have basic conversion working, you might want to explore more advanced features:\nMedia Handling - Download and process images and files Page References - Handle links between Notion pages Plugin system - Extend the functionality of notion-to-md Exporters - Save conversion output to different destinations Renderers - Create custom output formats Fetcher - Customize the conversion process That’s it! You’ve successfully set up notion-to-md v4 and converted your first page.","prerequisites#Prerequisites":"Before you can convert Notion pages to Markdown, you need to have a Notion integration set up."},"title":"Getting Started"},"/docs/v4/references/configuration/":{"data":{"":"This page documents all configuration options available in the notion-to-md v4 library. The library uses a builder pattern for configuration, making it easy to customize while maintaining readability.","advanced-types#Advanced Types":"For reference, these are the detailed types used in some configuration options. These types provide deeper insight into the structure of the data handled during conversion.\nMedia Types enum MediaStrategyType { DOWNLOAD = \"DOWNLOAD\", // Media is downloaded to local filesystem UPLOAD = \"UPLOAD\", // Media is uploaded to external service DIRECT = \"DIRECT\" // Original media URLs are used directly } interface MediaInfo { type: MediaStrategyType; // The strategy used for this media originalUrl: string; // The original Notion URL localPath?: string; // Path on local filesystem (for DOWNLOAD) uploadedUrl?: string; // URL after upload (for UPLOAD) transformedUrl?: string; // Final URL used in output mimeType?: string; // Media content type } interface MediaManifestEntry { mediaInfo: MediaInfo; // Complete media information lastEdited: string; // Last edit timestamp from Notion createdAt: string; // When the entry was first created updatedAt: string; // When the entry was last updated } Page Reference Types enum PageReferenceEntryType { PROPERTY = \"PROPERTY\", // URL derived from page property MANIFEST = \"MANIFEST\" // URL stored in reference manifest } interface PageReferenceEntry { url: string; // The URL for the page reference source: PageReferenceEntryType; // How the URL was determined lastUpdated: string; // When the reference was last updated } For more detailed information about these configuration options, see the specific guides for each component:\nBlock Fetcher Media Handling Page Reference Handler Plugins Renderer plugin Exporter plugin ","block-fetcher-configuration#Block Fetcher Configuration":"Block Fetcher is responsible for retrieving content from the Notion API. Its configuration controls what data is fetched and how the process is optimized.\ninterface BlockFetcherConfig { fetchPageProperties?: boolean; // Include page properties in output fetchComments?: boolean; // Include comments in output maxRequestsPerSecond?: number; // API rate limit (default: 3) batchSize?: number; // Batch size for concurrent requests (default: 3) trackMediaBlocks?: boolean; // Track blocks with media content trackPageRefBlocks?: boolean; // Track blocks with page references } Field Explanations fetchPageProperties: When true, notion page properties are included in the output. Essential for generating frontmatter in markdown or any other use case.\nfetchComments: When true, retrieves comments on blocks. Useful for collaborative workflows where comments might contain important information.\nmaxRequestsPerSecond: Controls the API rate limiting to prevent hitting Notion’s limits. The default of 3 is safe, but you can adjust based on your API tier.\nbatchSize: Determines how many blocks are processed in parallel. Higher values improve performance but increase memory usage. The default of 3 balances performance and resource usage.\ntrackMediaBlocks: When true, identifies and tracks blocks containing media (images, files, etc.) for special processing. Automatically enabled when using media handlers.\ntrackPageRefBlocks: When true, identifies and tracks blocks containing page references for link processing. Automatically enabled when using page reference handling.\nExample const n2m = new NotionConverter(notionClient) .configureFetcher({ fetchPageProperties: true, fetchComments: false, maxRequestsPerSecond: 5, batchSize: 10 }); ","exporter-configuration#Exporter Configuration":"Exporters determine how and where the converted content is saved or used. You can create custom exporters for any destination.\ninterface NotionExporter\u003cTConfig = unknown\u003e { export(data: ChainData): Promise\u003cvoid\u003e; } interface ChainData { pageId: string; // ID of the converted page blockTree: ExtendedFetcherOutput; // Raw block data metadata?: Record\u003cstring, any\u003e; // Additional metadata content: string; // Converted content } Field Explanations export(): The main method that handles the export process. Receives the complete ChainData object containing all information about the conversion.\npageId: The Notion page ID that was converted.\nblockTree: The complete tree of blocks retrieved from Notion, including all metadata and content.\nmetadata: Additional information collected during the conversion process, such as processing statistics or conversion settings.\ncontent: The final converted content string (e.g., markdown, HTML) ready for export.\nExample class FileSystemExporter implements NotionExporter { constructor(private outputDir: string) {} async export(data: ChainData): Promise\u003cvoid\u003e { const filename = `${data.pageId}.md`; const filepath = path.join(this.outputDir, filename); await fs.writeFile(filepath, data.content, 'utf-8'); } } const n2m = new NotionConverter(notionClient) .withExporter(new FileSystemExporter('./content')); ","media-handling-configuration#Media Handling Configuration":"notion-to-md v4 offers media handling to ensure images and files are properly processed during conversion. Two strategies are available: downloading files locally or uploading to an external service.\nDownload Strategy Use this strategy when you want to save Notion media files to your local filesystem or server and refer to them in your output. Ideal for static site generation.\ninterface DownloadStrategyConfig { outputDir: string; // Directory to save media files transformPath?: (localPath: string) =\u003e string; // Transform file paths for output preserveExternalUrls?: boolean; // Keep external URLs unchanged failForward?: boolean; // Continue on errors (default: true) } Field Explanations outputDir: The directory where media files will be saved. Must be accessible and writable by the application.\ntransformPath: A function that converts local file paths to the paths that will appear in the output. For example, converting /server/path/image.jpg to /public/images/image.jpg. This ensures URLs in the output content correctly reference the media files.\npreserveExternalUrls: When true, doesn’t download media from external sources (non-Notion URLs). Keeps the original URLs in the output. Useful when you want to preserve references to third-party content.\nfailForward: When true (default), continues processing even if a media file fails to download. The original URL will be used as a fallback. When false, errors during media processing will halt the conversion.\nExample const n2m = new NotionConverter(notionClient) .downloadMediaTo({ outputDir: './public/images', transformPath: (localPath) =\u003e `/images/${path.basename(localPath)}`, preserveExternalUrls: true }); Upload Strategy Use this strategy when you want to upload Notion media to an external service like AWS S3, Cloudinary, or a custom storage system.\ninterface UploadStrategyConfig { uploadHandler: (url: string, blockId: string) =\u003e Promise\u003cstring\u003e; // Upload function cleanupHandler?: (entry: MediaManifestEntry) =\u003e Promise\u003cvoid\u003e; // Cleanup function transformPath?: (uploadedUrl: string) =\u003e string; // Transform URLs preserveExternalUrls?: boolean; // Keep external URLs failForward?: boolean; // Continue on errors } Field Explanations uploadHandler: A function that receives the original media URL and block ID, handles the upload process, and returns the new URL. This is where you implement your custom upload logic.\ncleanupHandler: An optional function that cleans up media files when they’re no longer needed (e.g., when a block is deleted or changed). Helps prevent accumulating unused files. This is called internally when the media is no longer referenced.\ntransformPath: A function that transforms the URLs returned by your upload handler. Useful for adding CDN prefixes or modifying domains.\npreserveExternalUrls: When true, doesn’t upload media from external sources. Keeps the original URLs in the output.\nfailForward: When true (default), continues processing even if media upload fails. The original URL will be used as a fallback. When false, upload errors will halt the conversion.\nExample const n2m = new NotionConverter(notionClient) .uploadMediaUsing({ uploadHandler: async (url, blockId) =\u003e { // Upload file to S3/Cloudinary/etc return 'https://cdn.example.com/uploaded-file.jpg'; }, cleanupHandler: async (entry) =\u003e { // Delete file from storage when no longer needed }, transformPath: (url) =\u003e url.replace('s3.amazonaws.com', 'cdn.example.com') }); ","notionconverter-builder-methods#NotionConverter Builder Methods":"The main NotionConverter class provides several builder methods to configure different aspects of the conversion process. The builder pattern makes configuration intuitive and type-safe.\nBasic Configuration const n2m = new NotionConverter(notionClient) .configureFetcher({...}) // Configure block fetching behavior .downloadMediaTo({...}) // Configure media downloading .uploadMediaUsing({...}) // Configure media uploading .withPageReferences({...}) // Configure page reference handling .withRenderer(renderer) // Set custom renderer .withExporter(exporter); // Add output exporter ","page-reference-configuration#Page Reference Configuration":"The Page Reference handler manages links between Notion pages, ensuring they work properly in the output. This is especially important for websites or knowledge bases built from Notion content. You are required to provide URL where the page will be live once published. That will be used as reference for page links.\nℹ️ Read more about how to use page reference utility. interface PageRefConfig { UrlPropertyNameNotion?: string; // Property containing page URL baseUrl?: string; // Base URL for page references transformUrl?: (url: string) =\u003e string; // Custom URL transformation } Field Explanations UrlPropertyNameNotion: The name of a Notion page property that contains the URL or slug for the page. If provided, this property’s value will be used instead of generating a URL from the page ID.\nbaseUrl: The base URL that will be prepended to page references. For example, https://example.com/blog will transform references to https://example.com/blog/page-slug.\ntransformUrl: A function that customizes how URLs are generated or transformed. Useful for implementing custom slug generation, URL normalization, or adding path prefixes.\nExample const n2m = new NotionConverter(notionClient) .withPageReferences({ UrlPropertyNameNotion: 'slug', baseUrl: 'https://example.com/blog', transformUrl: (url) =\u003e url.toLowerCase().replace(/\\s+/g, '-') }); ","renderer-configuration#Renderer Configuration":"Renderers determine the output format of the conversion. notion-to-md v4 includes a default MDX renderer, but you can create custom renderers for any format.\nℹ️ Read more about how to create custom renderers. MDX Renderer Configuration The built-in MDX renderer supports frontmatter generation and customization.\ninterface FrontmatterConfig { include?: string[]; // Properties to include exclude?: string[]; // Properties to exclude rename?: Record\u003cstring, string\u003e; // Rename properties defaults?: Record\u003cstring, any\u003e; // Default values } interface MDXRendererConfig { frontmatter?: boolean | FrontmatterConfig; // Enable/configure frontmatter } Field Explanations frontmatter: Controls frontmatter generation. Can be:\ntrue: Generate frontmatter from all page properties false: Don’t generate frontmatter FrontmatterConfig: Configure detailed frontmatter behavior include: An array of property names to include in the frontmatter. If provided, only these properties will be used.\nexclude: An array of property names to exclude from the frontmatter. Useful when you want most properties except specific ones.\nrename: A mapping of original property names to new names. For example, { \"Created time\": \"date\" } will rename the “Created time” property to “date” in the output.\ndefaults: Default values for properties that might be missing. These values will be used if the corresponding property doesn’t exist or is empty.\nExample import { MDXRenderer } from 'notion-to-md'; const renderer = new MDXRenderer({ frontmatter: { include: ['title', 'date', 'tags'], rename: { title: 'name' }, defaults: { draft: false } } }); const n2m = new NotionConverter(notionClient) .withRenderer(renderer); "},"title":"Configuration"}}